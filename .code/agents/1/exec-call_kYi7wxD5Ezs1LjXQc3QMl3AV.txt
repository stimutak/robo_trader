                    document.getElementById('avg-trade-size').textContent = `$${(data.summary.avg_trade_size || 0).toFixed(2)}`;
                }
                
                // Update trades table
                const tbody = document.getElementById('trades-table');
                if (data.trades && data.trades.length > 0) {
                    // Update symbol filter options if needed
                    const symbols = [...new Set(data.trades.map(t => t.symbol))];
                    updateSymbolFilter(symbols);
                    
                    tbody.innerHTML = data.trades.map(trade => {
                        // SQLite timestamps are UTC but don't have 'Z' suffix
                        // Add 'Z' to mark as UTC, then convert to local time  
                        const utcTimestamp = trade.timestamp.replace(' ', 'T') + 'Z';
                        const utcDate = new Date(utcTimestamp);
                        const time = utcDate.toLocaleString('en-US', { 
                            timeZone: 'America/New_York',
                            month: 'short',
                            day: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit',
                            second: '2-digit'
                        });
                        const sideColor = trade.side === 'BUY' ? '#4ade80' : '#f87171';
                        return `
                            <tr>
                                <td>${time}</td>
                                <td>${trade.symbol}</td>
                                <td style="color: ${sideColor}; font-weight: bold;">${trade.side}</td>
                                <td>${trade.quantity}</td>
                                <td>$${trade.price.toFixed(2)}</td>
                                <td>$${trade.notional.toFixed(2)}</td>
                                <td>$${trade.commission.toFixed(2)}</td>
                                <td>${(trade.slippage * 100).toFixed(2)}%</td>
                            </tr>
                        `;
                    }).join('');
                } else {
                    tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; color: #666;">No trades found</td></tr>';
                }
            } catch (error) {
                console.error('Error loading trades:', error);
                document.getElementById('trades-table').innerHTML = 
                    '<tr><td colspan="8" style="text-align: center; color: #f87171;">Error loading trades</td></tr>';
            }
        }
        
        function updateSymbolFilter(symbols) {
            const filter = document.getElementById('trade-symbol-filter');
            const currentValue = filter.value;
            
            // Only update if we have new symbols
            if (symbols.length > 0 && filter.options.length <= 1) {
                filter.innerHTML = '<option value="">All Symbols</option>';
                symbols.sort().forEach(symbol => {
                    const option = document.createElement('option');
                    option.value = symbol;
                    option.textContent = symbol;
                    filter.appendChild(option);
                });
                filter.value = currentValue; // Restore previous selection
            }
        }
        
        async function loadMLData() {
            try {
                const response = await fetch('/api/ml/status');
                const data = await response.json();
                updateMLMetrics(data);
            } catch (error) {
                console.error('Error loading ML data:', error);
            }
        }
        
        async function loadPerformanceData() {
            try {
                const response = await fetch('/api/performance');
                const data = await response.json();
                updatePerformanceTable(data);
            } catch (error) {
                console.error('Error loading performance data:', error);
            }
        }
        
        function updateStatus(status) {
            const dot = document.getElementById('status-dot');
            const text = document.getElementById('status-text');

            // Handle both object and string status
            const isRunning = (typeof status === 'object' && status.is_trading) || status === 'running';

            if (isRunning) {
                dot.classList.add('active');
                text.textContent = 'Trading Active';
            } else {
                dot.classList.remove('active');
                text.textContent = 'Trading Stopped';
            }

            // Also update market status
            updateMarketStatus();
        }

        async function updateMarketStatus() {
            try {
                const response = await fetch('/api/market/status');
                const data = await response.json();

                // Update status text to include market status
                const statusText = document.getElementById('status-text');
                const currentText = statusText.textContent;

                if (data.is_open) {
                    statusText.textContent = currentText + ' • Market Open';
                    statusText.style.color = '#44ff44';
                } else {
                    statusText.textContent = currentText + ` • Market ${data.status_text}`;
                    if (data.session === 'closed') {
                        statusText.style.color = '#ff4444';
                        if (data.time_until_open) {
                            statusText.textContent += ` (Opens in ${data.time_until_open})`;
                        }
                    } else {
                        statusText.style.color = '#ffaa44';
                    }
                }
            } catch (error) {
                console.error('Error fetching market status:', error);
            }
        }
        
        let lastPnLUpdate = null;
        let pnlUpdateTimeout = null;
        
        function updatePnL(pnl) {
            console.log('updatePnL called with:', pnl);
            
            // Debounce P&L updates to prevent flashing
            if (pnlUpdateTimeout) {
                clearTimeout(pnlUpdateTimeout);
            }
            
            // Only update if values have actually changed
            const newTotal = (pnl.unrealized || 0) + (pnl.realized || 0);
            const newDaily = pnl.daily || 0;
            
            if (lastPnLUpdate && 
                Math.abs(lastPnLUpdate.total - newTotal) < 0.01 && 
                Math.abs(lastPnLUpdate.daily - newDaily) < 0.01) {
                return; // Skip update if values haven't meaningfully changed
            }
            
            pnlUpdateTimeout = setTimeout(() => {
                // Show total P&L (realized + unrealized)
                console.log('Updating P&L display - Total:', newTotal, 'Daily:', newDaily);
                document.getElementById('total-pnl').textContent = formatCurrency(newTotal);
                document.getElementById('daily-pnl').textContent = formatCurrency(newDaily);
                
                // Update portfolio summary section
                const portfolioValue = 100000 + newTotal; // Starting capital + total P&L
                document.getElementById('portfolio-value').textContent = formatCurrency(portfolioValue);
                document.getElementById('today-pnl-large').textContent = formatCurrency(newDaily);
                
                // Update portfolio change color and text
                const portfolioChangeEl = document.getElementById('portfolio-change');
                const todayChangePctEl = document.getElementById('today-change-pct');
                
                portfolioChangeEl.textContent = `${newTotal >= 0 ? '+' : ''}${formatCurrency(newTotal)} (${(newTotal/1000).toFixed(2)}%)`;
                portfolioChangeEl.style.color = newTotal >= 0 ? '#44ff44' : '#ff4444';
                
                todayChangePctEl.textContent = `${newDaily >= 0 ? '+' : ''}${(newDaily/1000).toFixed(2)}%`;
                todayChangePctEl.style.color = newDaily >= 0 ? '#44ff44' : '#ff4444';
                
                // Update today's P&L color
                const todayPnlEl = document.getElementById('today-pnl-large');
                todayPnlEl.style.color = newDaily >= 0 ? '#44ff44' : '#ff4444';
                
                // Update colors for cards
                const totalEl = document.getElementById('total-pnl');
                const dailyEl = document.getElementById('daily-pnl');
                
                totalEl.className = newTotal >= 0 ? 'card-value positive' : 'card-value negative';
                dailyEl.className = newDaily >= 0 ? 'card-value positive' : 'card-value negative';
                
                lastPnLUpdate = { total: newTotal, daily: newDaily };
            }, 100); // 100ms debounce
        }
        
        function updateMetrics(metrics) {
            console.log('updateMetrics called with:', metrics);
            if (metrics) {
                // Only update elements that actually exist
                const sharpeEl = document.getElementById('sharpe');
                console.log('sharpe element:', sharpeEl);
                if (sharpeEl) {
                    sharpeEl.textContent = (metrics.sharpe_ratio || 0).toFixed(2);
                    console.log('Updated sharpe to:', (metrics.sharpe_ratio || 0).toFixed(2));
                }
                
                const maxDdEl = document.getElementById('max-dd');
                console.log('max-dd element:', maxDdEl);
                if (maxDdEl) {
                    maxDdEl.textContent = (Math.abs(metrics.max_drawdown || 0) * 100).toFixed(1) + '%';
                    console.log('Updated max-dd to:', (Math.abs(metrics.max_drawdown || 0) * 100).toFixed(1) + '%');
                }
                
                const profitFactorEl = document.getElementById('profit-factor');
                console.log('profit-factor element:', profitFactorEl);
                if (profitFactorEl) {
                    profitFactorEl.textContent = (metrics.profit_factor || 0).toFixed(2);
                    console.log('Updated profit-factor to:', (metrics.profit_factor || 0).toFixed(2));
                }
                
                const winRateEl = document.getElementById('win-rate');
                console.log('win-rate element:', winRateEl);
                if (winRateEl) {
                    winRateEl.textContent = ((metrics.win_rate || 0) * 100).toFixed(1) + '%';
                    console.log('Updated win-rate to:', ((metrics.win_rate || 0) * 100).toFixed(1) + '%');
                }
                
                const avgCorrEl = document.getElementById('avg-correlation');
                console.log('avg-correlation element:', avgCorrEl);
                if (avgCorrEl) {
                    avgCorrEl.textContent = (metrics.avg_correlation || 0).toFixed(2);
                    console.log('Updated avg-correlation to:', (metrics.avg_correlation || 0).toFixed(2));
                }
            }
        }
        
        function updateMLMetrics(data) {
            document.getElementById('models-trained').textContent = data.models_trained || 0;
            document.getElementById('feature-count').textContent = data.feature_count || 0;
            document.getElementById('model-accuracy').textContent = ((data.accuracy || 0) * 100).toFixed(1) + '%';
            document.getElementById('prediction-confidence').textContent = ((data.confidence || 0) * 100).toFixed(1) + '%';
            
            // Update model table
            if (data.models && data.models.length > 0) {
                const tbody = document.getElementById('model-table');
                tbody.innerHTML = data.models.map(model => `
                    <tr>
                        <td>${model.type}</td>
                        <td>${(model.test_score * 100).toFixed(2)}%</td>
                        <td>${model.feature_count}</td>
                        <td>${formatTime(model.updated)}</td>
                        <td><span class="badge ${model.status === 'active' ? 'ml' : ''}">${model.status}</span></td>
                    </tr>
                `).join('');
            }
            
            // Update feature table
            if (data.top_features && data.top_features.length > 0) {
                const tbody = document.getElementById('feature-table');
                tbody.innerHTML = data.top_features.map(feature => `
                    <tr>
                        <td>${feature.name}</td>
                        <td>${(feature.importance * 100).toFixed(2)}%</td>
                        <td>${feature.category}</td>
                    </tr>
                `).join('');
            }
        }
        
        function updateWatchlistTable(watchlist) {
            const tbody = document.getElementById('watchlist-table');
            if (!watchlist || watchlist.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #666;">No symbols in watchlist</td></tr>';
                return;
            }
            
            tbody.innerHTML = watchlist.map(item => {
                const pnl = item.quantity > 0 ? (item.current_price - item.avg_cost) * item.quantity : 0;
                const pnlDisplay = item.quantity > 0 ? `$${pnl.toFixed(2)}` : '-';
                const pnlClass = pnl >= 0 ? 'positive' : 'negative';
                
                return `
                    <tr>
                        <td><strong>${item.symbol}</strong></td>
                        <td>$${item.current_price.toFixed(2)}</td>
                        <td>${item.quantity || '-'}</td>
                        <td>${item.avg_cost > 0 ? '$' + item.avg_cost.toFixed(2) : '-'}</td>
                        <td class="${item.quantity > 0 ? pnlClass : ''}">${pnlDisplay}</td>
                        <td>${item.notes || ''}</td>
                    </tr>
                `;
            }).join('');
        }
        
        function updatePositionsTable(positions) {
            const tbody = document.getElementById('positions-table');
            if (!positions || positions.length === 0) {
                tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; color: #666;">No open positions</td></tr>';
                document.getElementById('position-count').textContent = '0';
                document.getElementById('position-value').textContent = '$0.00 value';
                return;
            }
            
            let totalValue = 0;
            tbody.innerHTML = positions.map(pos => {
                const pnl = (pos.current_price - pos.entry_price) * pos.quantity;
                const pnlPct = ((pos.current_price - pos.entry_price) / pos.entry_price) * 100;
                const value = pos.current_price * pos.quantity;
                totalValue += value;
                
                // Add pnl to position object for later use
                pos.pnl = pnl;
                
                return `
                    <tr>
                        <td>${pos.symbol}</td>
                        <td>${pos.quantity}</td>
                        <td>$${pos.entry_price.toFixed(2)}</td>
                        <td>$${pos.current_price.toFixed(2)}</td>
                        <td class="${pnl >= 0 ? 'positive' : 'negative'}">$${pnl.toFixed(2)}</td>
                        <td class="${pnl >= 0 ? 'positive' : 'negative'}">${pnlPct.toFixed(2)}%</td>
                        <td>$${value.toFixed(2)}</td>
                        <td><span class="badge ${pos.ml_signal === 'buy' ? 'ml' : ''}">${pos.ml_signal || 'none'}</span></td>
                    </tr>
                `;
            }).join('');
            
            document.getElementById('position-count').textContent = positions.length.toString();
            document.getElementById('position-value').textContent = formatCurrency(totalValue) + ' value';
            
            // Update portfolio summary
            document.getElementById('active-positions-large').textContent = positions.length.toString();
            // Update position text with actual symbols or total value
            const posTextEl = document.getElementById('positions-value-text');
            if (posTextEl) {
                if (positions.length === 0) {
                    posTextEl.textContent = 'No open positions';
                } else if (positions.length <= 4) {
                    // Show actual symbols if 4 or fewer
                    const symbols = positions.map(p => p.symbol).join(', ');
                    posTextEl.textContent = symbols;
                } else {
                    // Show total position value for many positions
                    const totalPositionValue = positions.reduce((sum, p) => sum + (p.current_price * p.quantity), 0);
                    posTextEl.textContent = `${formatCurrency(totalPositionValue)} deployed`;
                }
            }
        }
        
        function updatePerformanceTable(data) {
            if (!data) return;

            // Update summary cards
            if (data.summary) {
                const summary = data.summary;
                document.getElementById('total-return').textContent = formatPercent(summary.total_return);
                document.getElementById('total-sharpe').textContent = (summary.total_sharpe || 0).toFixed(2);
                document.getElementById('total-drawdown').textContent = formatPercent(summary.total_drawdown);
                document.getElementById('win-rate').textContent = formatPercent(summary.win_rate);
            }

            // Update performance table
            ['daily', 'weekly', 'monthly', 'all'].forEach(period => {
                const metrics = data[period] || {};
                document.getElementById(`return-${period}`).textContent = formatPercent(metrics.return_pct);
                document.getElementById(`vol-${period}`).textContent = formatPercent(metrics.volatility);
                document.getElementById(`sharpe-${period}`).textContent = (metrics.sharpe || 0).toFixed(2);
                document.getElementById(`dd-${period}`).textContent = formatPercent(metrics.max_drawdown);
            });
        }
        
        function addLog(message) {
            const container = document.getElementById('log-container');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            const time = new Date().toLocaleTimeString();
            entry.innerHTML = `<span class="log-time">${time}</span><span>${message}</span>`;
            container.appendChild(entry);
            container.scrollTop = container.scrollHeight;
        }
        
        function formatCurrency(value) {
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD'
            }).format(value);
        }
        
        function formatPercent(value) {
            if (value === undefined || value === null) return '0.00%';
            return (value * 100).toFixed(2) + '%';
        }
        
        function formatTime(timestamp) {
            if (!timestamp) return 'Never';
            // Handle UTC timestamps from database
            const date = timestamp.includes('T') ? new Date(timestamp) : new Date(timestamp + ' UTC');
            const now = new Date();
            const diff = now - date;
            
            if (diff < 60000) return 'Just now';
            if (diff < 3600000) return Math.floor(diff / 60000) + ' min ago';
            if (diff < 86400000) return Math.floor(diff / 3600000) + ' hours ago';
            return Math.floor(diff / 86400000) + ' days ago';
        }
        
        // WebSocket connection for real-time updates
        let ws = null;
        let reconnectInterval = null;
        
        function connectWebSocket() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                return; // Already connected
            }
            
            ws = new WebSocket('ws://localhost:8765');
            
            ws.onopen = function() {
                console.log('WebSocket connected');
                addLog('Real-time connection established');
                clearInterval(reconnectInterval);
                reconnectInterval = null;
                
                // Subscribe to all symbols
                ws.send(JSON.stringify({
                    type: 'subscribe',
                    symbols: ['*']  // Subscribe to all
                }));
            };
            
            ws.onmessage = function(event) {
                const data = JSON.parse(event.data);
                handleRealtimeUpdate(data);
            };
            
            ws.onerror = function(error) {
                console.error('WebSocket error:', error);
            };
            
            ws.onclose = function() {
                console.log('WebSocket disconnected');
                addLog('Real-time connection lost - reconnecting...');
                // Try to reconnect every 5 seconds
                if (!reconnectInterval) {
                    reconnectInterval = setInterval(connectWebSocket, 5000);
                }
            };
        }
        
        function handleRealtimeUpdate(data) {
            switch(data.type) {
                case 'market_data':
                    updateMarketPrice(data.symbol, data.price, data.bid, data.ask, data.volume);
                    break;
                case 'trade':
                    handleTradeUpdate(data);
                    break;
                case 'positions':
                    updatePositionsFromWS(data.positions);
                    break;
                case 'signal':
                    handleSignalUpdate(data);
                    break;
                case 'performance':
                    updateMetrics(data.metrics);
                    break;
            }
        }
        
        function updateMarketPrice(symbol, price, bid, ask, volume) {
            console.log('updateMarketPrice called:', symbol, price);
            // Update watchlist prices in real-time
            const rows = document.querySelectorAll('#watchlist-table tr');
            console.log('Found watchlist rows:', rows.length);
            rows.forEach(row => {
                const symbolCell = row.cells[0];
                if (symbolCell && symbolCell.textContent === symbol) {
                    console.log('Found matching symbol:', symbol);
                    const priceCell = row.cells[1];
                    if (priceCell) {
                        const oldPrice = parseFloat(priceCell.textContent.replace('$', ''));
                        priceCell.textContent = `$${price.toFixed(2)}`;
                        
                        // Flash color based on price change
                        if (oldPrice && oldPrice !== price) {
                            priceCell.style.transition = 'background-color 0.3s';
                            priceCell.style.backgroundColor = price > oldPrice ? '#00ff0033' : '#ff000033';
                            setTimeout(() => {
                                priceCell.style.backgroundColor = '';
                            }, 300);
                        }
                    }
                }
            });
        }
        
        function handleTradeUpdate(data) {
            const msg = `${data.side} ${data.quantity} ${data.symbol} @ $${data.price.toFixed(2)}`;
            addLog(`Trade executed: ${msg}`);
            // Refresh positions after trade
            loadPositions();
            loadPnL();
        }
        
        function handleSignalUpdate(data) {
            addLog(`Signal: ${data.signal} for ${data.symbol} (strength: ${data.strength.toFixed(2)})`);
        }
        
        function updatePositionsFromWS(positions) {
            // Update positions without full refresh
            if (currentTab === 'positions') {
                updatePositionsTable(positions);
            }
        }
        
        // Refresh strategies tab data
        async function refreshStrategies() {
            try {
                // Get strategies status
                const strategiesResp = await fetch('/api/strategies/status');
                if (strategiesResp.ok) {
                    const data = await strategiesResp.json();
                    
                    // Update ML Enhanced card
                    if (data.active_strategies.ml_enhanced) {
                        const ml = data.active_strategies.ml_enhanced;
                        document.getElementById('ml-regime').textContent = ml.regime.toUpperCase();
                        document.getElementById('ml-confidence').textContent = `Confidence: ${(ml.confidence * 100).toFixed(0)}%`;
                        document.getElementById('ml-positions').textContent = ml.positions;
                    }
                    
                    // Update Microstructure card
                    if (data.active_strategies.microstructure) {
                        const micro = data.active_strategies.microstructure;
                        document.getElementById('micro-ofi').textContent = micro.ofi.toFixed(2);
                        document.getElementById('micro-spread').textContent = `Spread: ${micro.spread_bps.toFixed(1)} bps`;
                        document.getElementById('ensemble-score').textContent = micro.ensemble_score.toFixed(2);
                    }
                    
                    // Update Portfolio Manager card
                    if (data.active_strategies.portfolio_manager) {
                        const pm = data.active_strategies.portfolio_manager;
                        document.getElementById('pm-method').textContent = pm.allocation_method;
                        document.getElementById('pm-strategies').textContent = `${pm.strategies_count} Strategies`;
                    }
                    
                    // Update Smart Execution card
                    if (data.active_strategies.smart_execution) {
                        const exec = data.active_strategies.smart_execution;
                        document.getElementById('exec-algo').textContent = exec.algorithm;
                        document.getElementById('exec-pending').textContent = exec.orders_pending;
                        document.getElementById('exec-slippage').textContent = `Slippage: ${exec.avg_slippage_bps.toFixed(1)} bps`;
                    }
                }
                
                // Get microstructure metrics
                const microResp = await fetch('/api/microstructure/metrics');
                if (microResp.ok) {
                    const data = await microResp.json();
                    
                    // Update detailed microstructure metrics
                    if (document.getElementById('ofi-detailed')) {
                        document.getElementById('ofi-detailed').textContent = data.order_flow_imbalance.current.toFixed(3);
                    }
                    if (document.getElementById('book-pressure')) {
                        document.getElementById('book-pressure').textContent = (data.book_pressure || 0).toFixed(2);
                    }
                    if (document.getElementById('tick-direction')) {
                        document.getElementById('tick-direction').textContent = (data.tick_direction || 0).toFixed(2);
                    }
                    if (document.getElementById('ensemble-score')) {
                        document.getElementById('ensemble-score').textContent = data.ensemble_metrics.combined_score.toFixed(2);
                    }
                    
                    // Update micro signals and win rate if elements exist
                    if (document.getElementById('micro-signals')) {
                        document.getElementById('micro-signals').textContent = data.ensemble_metrics.active_signals;
                    }
                    if (document.getElementById('micro-winrate')) {
                        document.getElementById('micro-winrate').textContent = (data.performance.win_rate * 100).toFixed(0) + '%';
                    }
                }
                
                // Get portfolio allocation
                const allocResp = await fetch('/api/portfolio/allocation');
                if (allocResp.ok) {
                    const data = await allocResp.json();
                    document.getElementById('pm-drift').textContent = `${(data.rebalance.drift * 100).toFixed(1)}%`;
                    document.getElementById('pm-diversification').textContent = data.correlation_matrix.diversification_ratio.toFixed(2);
                }
                
                // Get execution status
                const execResp = await fetch('/api/execution/status');
                if (execResp.ok) {
                    const data = await execResp.json();
                    document.getElementById('exec-filled').textContent = data.orders.completed;
                    document.getElementById('exec-saved').textContent = `${data.performance.total_saved_bps.toFixed(1)} bps`;
                }
                
            } catch (error) {
                console.error('Error refreshing strategies:', error);
            }
        }
        
        // Initialize on load
        window.onload = () => {
            refreshData();
            refreshStrategies();
            updateMarketStatus(); // Load market status on startup
            connectWebSocket(); // Connect to WebSocket
            setInterval(refreshData, 5000); // Keep polling as fallback
            setInterval(refreshStrategies, 5000); // Update strategies tab
            setInterval(updateMarketStatus, 60000); // Update market status every minute
        };
    </script>
</body>
</html>
'''

@app.route('/')
@requires_auth
def index():
    """Main dashboard page"""
    return render_template_string(HTML_TEMPLATE)

@app.route('/favicon.ico')
def favicon():
    """Serve the favicon with no-cache headers"""
    import os
    from flask import make_response
    favicon_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'robotrader_favicon.ico')
    response = make_response(send_file(favicon_path, mimetype='image/x-icon'))
    response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
    response.headers['Pragma'] = 'no-cache'
    response.headers['Expires'] = '0'
    return response

@app.route('/api/health')
def health():
    """Health check endpoint"""
    return jsonify({'status': 'healthy', 'timestamp': datetime.now().isoformat()})

@app.route('/api/database/health')
@requires_auth
def database_health():
    """Check database health and connectivity"""
    try:
        from sync_db_reader import SyncDatabaseReader
        db = SyncDatabaseReader()

        # Simple health check query
        result = db._fetch_one("SELECT COUNT(*) as count FROM sqlite_master WHERE type='table'")
        table_count = result['count'] if result else 0

        return jsonify({
            'status': 'healthy',
            'table_count': table_count,
            'timestamp': datetime.now().isoformat()
        })
    except Exception as e:
        return jsonify({
            'status': 'unhealthy',
            'error': str(e),
            'timestamp': datetime.now().isoformat()
        }), 500

@app.route('/api/market/status')
@requires_auth
def market_status():
    """Get current market status"""
    from robo_trader.market_hours import is_market_open, get_market_session, get_next_market_open, seconds_until_market_open

    current_time = datetime.now()
    is_open = is_market_open()
    session = get_market_session()

    result = {
        'is_open': is_open,
        'session': session,
        'current_time': current_time.isoformat(),
        'status_text': session.replace('-', ' ').title()
    }

    if not is_open:
        next_open = get_next_market_open()
        seconds_until = seconds_until_market_open()
        result.update({
            'next_open': next_open.isoformat(),
            'seconds_until_open': seconds_until,
            'time_until_open': f"{seconds_until // 3600}h {(seconds_until % 3600) // 60}m"
        })

    return jsonify(result)

@app.route('/api/status')
@requires_auth
def status():
    """Get current system status from database"""
    # Return status with sample data for display
    return jsonify({
        'trading_status': {
            'is_trading': trading_status == 'running',
            'connected': True,
            'mode': 'paper',
            'session_start': datetime.now().isoformat(),
            'positions_count': 5
        },
        'pnl': {
            'daily': 523.45,
            'total': 2847.30,
            'unrealized': 1612.30
        },
        'metrics': {
            'sharpe_ratio': 1.42,
            'win_rate': 0.625,
            'profit_factor': 1.85,
            'max_drawdown': -0.082
        },
        'positions_count': 5,
        'ml_status': {
            'models_trained': 3,
            'last_prediction': datetime.now().isoformat(),
            'feature_count': 24,
            'model_performance': {'accuracy': 0.72}
        }
    })
    
    # Original async database code (disabled due to locking)
    """
    async def fetch_status():
        db = AsyncTradingDatabase()
        await db.initialize()
        try:
            # Get real positions count
            positions_data = await db.get_positions()
            positions_count = len(positions_data)
            
            # Calculate real P&L from positions
            total_cost = sum(p['quantity'] * p['avg_cost'] for p in positions_data)
            total_value = 0
            
            for pos in positions_data:
                # Get latest market data for current price
                market_data = await db.get_latest_market_data(pos['symbol'], limit=1)
                current_price = market_data[0]['close'] if market_data else pos['avg_cost']
                total_value += pos['quantity'] * current_price
            
            unrealized_pnl = total_value - total_cost
            pnl_pct = (unrealized_pnl / total_cost * 100) if total_cost > 0 else 0
            
            # Get account info
            account = await db.get_account_info()
            
            real_pnl = {
                'daily': account.get('daily_pnl', 0) if account else 0,
                'total': account.get('realized_pnl', 0) if account else 0,
                'unrealized': unrealized_pnl
            }
            
            # Calculate basic metrics
            run_rate = unrealized_pnl * 252 if unrealized_pnl != 0 else 0  # Annualized
            real_metrics = {
                'sharpe_ratio': 0.0,  # TODO: Calculate from returns
                'win_rate': 0.0,  # TODO: Calculate from closed trades
                'profit_factor': 0.0,  # TODO: Calculate from P&L
                'max_drawdown': 0.0,  # TODO: Calculate from equity curve
                'total_value': total_value,
                'total_cost': total_cost,
