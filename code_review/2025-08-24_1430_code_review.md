────────────────────────────────────────────────────────────────────────

SYSTEM PROMPT — "Decisive, Risk‑Bounded Trader (Equities‑Only)"

Role
You are an elite, data‑driven discretionary/quant hybrid focused on U.S. equities. Your job is to produce positive risk‑adjusted returns net of costs by acting decisively when edge exists and standing down when it doesn't.

Inputs provided by host
Real‑time and historical OHLCV; rolling volatility statistics (e.g., ATR, realized σ); trend/mean‑reversion features (SMAs/EMAs, breakouts, pullbacks); breadth/ETF context; earnings and macro calendars; open positions and P&L; transaction‑cost and slippage model; symbol whitelist; account equity and risk limits. If anything is missing, emit "MISSING:" and degrade gracefully (no trade if key data is missing).

Guardrails (must pass before any trade)
Per‑trade risk ≤ 0.50% of equity. Daily max drawdown −2.0%; weekly −5.0%. Liquidity floor: ADV ≥ $3M and bid‑ask ≤ 1.0% of mid for the equity. Correlation control: do not push more than 35% of portfolio exposure into any one sector/theme cluster. No microcaps/pinks.

Setups you may act on
Event‑driven (earnings/guidance), momentum/breakout (RVOL‑supported structure), mean‑reversion (2–3σ dislocations into defined levels), and simple stat‑arb/pairs within equities/ETFs. Every trade must specify explicit invalidation (price level or structure break) and a time‑stop.

Edge threshold and action rule
Compute EV = p_win*avg_win − (1−p_win)*avg_loss − costs − slippage. Require risk:reward ≥ 1.8:1 or EV>0 with p_win ≥ 0.45 and a clear invalidation. Produce Conviction 0–100 from signal strength, regime fit, liquidity, data completeness, and correlation conflicts.
Act when Conviction ≥ 55 and all guardrails pass. If Conviction 45–54 and cash > 70% and regime is favorable, allow a half‑size probe with tighter stops. If two sessions pass with 0 trades but ≥2 setups ≥50, propose the single best at half size (still guardrail‑clean). If nothing reaches 50, return NEUTRAL with a watchlist and explicit triggers.

Sizing (clip‑Kelly within hard caps)
Map Conviction to a fraction of the 0.50% risk cap: 55–64 → 0.30×; 65–74 → 0.60×; 75–84 → 0.85×; 85–100 → 1.00× (only if liquidity/correlation are clean).
Shares = (equity × risk_bps/10,000) ÷ (ATR_mult × ATR). Use ATR_mult ≈ 1.2 for trend continuation and 0.8 for mean‑reversion.

Management
Hard stop at invalidation or −1.2× planned risk; time‑stop after the catalyst passes or 2–3 sessions without progress. Scale‑out 1/3 at +1R, 1/3 at +2R, trail remainder by swing/EMA.

Bias controls
Penalize persistent "no‑trade" behavior when qualifying setups exist. Always compare the top three candidates by EV per unit of risk and implementation cost; pick one if correlation budget allows only one.

Output (single JSON object; host validates)
mode (trade|adjust|exit|neutral|watchlist), timestamp_utc, universe_checked, one best recommendation with: ticker, direction, entry (type/price/TIF), position_size (risk_bps, notional, shares), stops (hard, time), targets (levels or trailing rule), thesis (setup, catalyst, r_r, p_win, ev%), costs (fees_est, slippage_bps), conviction, compliance_checks (liquidity_ok, correlation_ok), watchlist with triggers, risk_state (day_dd_bps, week_dd_bps, cash_pct), notes.

Aggressiveness dial
level ∈ {0,1,2,3}. 0 = very conservative (threshold 60; smaller size map). 1 = default (55). 2 = assertive (52). 3 = opportunistic within guardrails (50 and require r:r ≥ 2.0).

Ethics/compliance
Policy engine only; respect broker/regulatory constraints.

Minimal one‑liner (if you want just a sentence)
Be decisive and data‑driven; act on the single best equity idea when Conviction ≥ 55 and guardrails pass; allow half‑size probes for 50–54 in favorable regimes; require r:r ≥ 1.8 or EV>0 with p_win ≥ 0.45 and explicit stops/time‑stops; otherwise return NEUTRAL with triggers.

────────────────────────────────────────────────────────────────────────

CURRENT‑STATE CODE REVIEW (EQUITIES‑ONLY) — main branch

What's strong (keep and extend)
• Risk spine is real: daily loss cap, per‑symbol exposure, leverage, plus optional per‑order and per‑day notional ceilings. That's unusually good for a fresh bot. The code enforces these in RiskManager.validate_order.
• Paper execution with slippage: the PaperExecutor applies a symmetric slippage (bps) around the limit price and returns fills deterministically. Great for reproducible paper runs. Note: the docstring still says "does not model slippage."
• Deterministic market data: IBKRClient.fetch_recent_bars plus normalize_bars_df lower‑cases columns, coerces numerics, drops NaNs, and sorts chronologically — fewer brittle surprises downstream.
• Operational posture: runner.py wires config, retry/backoff for IB connect and data fetch, database persistence, portfolio accounting, CLI flags (SMA windows, slippage bps, per‑order/day notional caps, default cash), and a --confirm-live interlock. Logging is centralized.
• Persistence and a minimal dashboard: SQLite schema for positions/trades/account/market_data/signals; a simple Flask dashboard surfaces equity, P&L, positions, trades. Good scaffolding for observability.
• Tests exist and run fast: risk limits and SMA signals have unit tests — nice CI affordance.

Gaps that block "decisive but safe" (and the exact fixes)
A) Sizing is not tied to invalidation distance. position_size uses a flat fraction of cash/equity; runner even passes equity as "cash_available". True risk drifts with stop width. Fix: base shares on risk_bps ÷ (ATR_mult × ATR or explicit stop distance); require explicit invalidation/time‑stop from the decision layer. Also, either pass cash or rename the parameter to avoid ambiguity.
B) No weekly drawdown stop. Add a −5% weekly cap alongside the existing daily guard in RiskManager.validate_order. Block new risk once tripped.
C) No liquidity/spread gates. Add a market_meta check before orders: ADV ≥ $3M and spread ≤ 1.0%. Derive ADV from recent historical bars and spread from live bid/ask via IBKR.
D) No correlation budgets. Implement sector/theme buckets and block orders that would push any bucket over 35% of exposure.
E) No EV/risk:reward gating. Add a small edge module: compute p_win and win/loss magnitudes from recent outcomes (or priors), subtract fees + regime‑aware slippage, and require r:r ≥ 1.8 or EV>0 with p_win ≥ 0.45 before acting.
F) No LLM decision layer yet. Add a schema‑forced single JSON decision (tool‑use), validate with Pydantic, and persist prompt hash, model id, and decision JSON with every order.
G) Minor correctness/polish. execution.py docstring contradicts behavior (it does model slippage); fix the comment. runner.py has a no‑op "rename 'close'" branch; remove it. Move the SQLite file from repo root to data/ and make the path env‑configurable.

What (non‑instrument) ideas to cherry‑pick from the "options" branch without touching options
• The schema‑forced AI decision layer (single JSON object; strict validation; UTC timestamps; "conviction validation" and datetime serialization fixes). These are instrument‑agnostic and perfect for equities.
• The EV/Kelly components, but keep clip‑Kelly within the 0.50% hard cap; sizing stays in code, never in the model.
• The news/event pipeline and dashboard polish — with de‑duplication and symbol relevance gating — to stabilize prompts and reduce flapping.
• The switch to IBKR TWS Desktop only (drop Web Gateway), plus hardening around retries/timeouts.
These all map cleanly to equities and don't require options/derivatives.

────────────────────────────────────────────────────────────────────────

DETAILED, STAGED PLAN — EQUITIES‑ONLY

Stage 0 — Repo hygiene and parity
• Move SQLite to data/trading_data.db; parameterize via env; keep .gitignore clean.
• Fix the slippage docstring; remove the redundant "close rename" branch in runner.py.

Stage 1 — Market‑meta and risk gates
• Add market_meta to compute ADV (rolling average from recent bars) and spread% (live bid/ask); block below thresholds.
• Add a −5% weekly drawdown brake in RiskManager.
• Implement correlation buckets (sector/theme) with a ≤35% cap.

Stage 2 — EV/edge and stop‑aware sizing
• Add an edge module: p_win, avg_win/avg_loss from recent distribution; subtract costs + spread×RVOL slippage; compute EV and r:r.
• Change sizing: shares = (equity × risk_bps/10,000) ÷ (ATR_mult × ATR or explicit stop distance). Require explicit invalidation and a time‑stop.

Stage 3 — LLM policy layer (equities‑only, paper mode)
• Add a Decision JSON schema (fields listed in the prompt) and force the model to return exactly one tool‑use payload.
• Validate with Pydantic; refuse any malformed output; persist (prompt_hash, model_id, decision_json) per order.
• Keep sizing/risk in code; model provides thesis, stop/targets, and risk_bps only.

Stage 4 — Observability and calibration
• JSON logs with decision JSON, prompt hash, model id, blocked‑by‑rule reasons, decision→order latency, and slippage bps.
• Rolling 30‑day Brier and EV error; alert if Brier > 0.20.

Stage 5 — Optional UI and news
• If the dashboard helps you operate, keep it, but prove every route still calls the same risk gate as the runner.
• Add news/events ingestion with de‑dupe and symbol relevance; use it to annotate context but not to bypass EV/liquidity/correlation gates.

────────────────────────────────────────────────────────────────────────

ACCEPTANCE TEST MATRIX (BEFORE LLM‑DRIVEN PAPER)
1. Drawdowns: simulate day −2.1% and week −5.1% → NO‑TRADE with a clear reason; logging confirms the brake. (Daily exists; weekly is new.)
2. Per‑trade risk: wide vs narrow stops keep risk ≤ 0.50% equity by construction; verify shares sizing formula.
3. Liquidity/spread: a low‑ADV/wide‑spread name is blocked; a liquid/tight‑spread name passes.
4. Correlation: adding a third sector‑peer that would push the bucket >35% exposure is blocked.
5. EV gating: between two candidates, only the higher EV per unit risk routes; EV ≤ 0 or r:r < 1.8:1 ⇒ no trade.
6. Schema robustness: fuzz the model output (missing/extra fields, wrong types) — 100% rejected, no orders routed.
7. Paper fills: symmetric slippage bps applied on entry/exit; P&L reconciles with recorded slippage.
8. Provenance: every order row includes prompt hash, model id, decision JSON, features hash (data snapshot).
9. No‑stall probe: if two sessions pass with ≥1 setup ≥50 and 0 fills, the half‑size probe rule can fire when guardrails and EV permit.

────────────────────────────────────────────────────────────────────────

QUICK WINS (ONE‑HOUR FIXES)

• Update the execution.py docstring to match reality (it does model bps slippage).
• Remove the no‑op "close rename" branch and rely on your bar normalizer.
• Rename position_size's first argument or pass cash instead of equity from runner for clarity.
• Move the DB to data/ and make the path configurable.

────────────────────────────────────────────────────────────────────────

BOTTOM LINE

You already have the right bones for a safe, testable equities bot: risk caps that actually do something, deterministic data, a clean paper executor, persistence, and CI‑friendly tests. Tighten the risk gates (weekly DD, liquidity/spread, correlation), make sizing stop‑aware, add EV thresholds, and wire the schema‑forced LLM policy layer. That gives you the behavior you want: acts when the edge is real, refuses to bleed when it isn't — with no options/derivatives/crypto/commodities in the way.

(Engineering guidance only; this is not financial advice.)

Sources I inspected
Repo README and feature list; RiskManager with per‑order/day notional caps and exposure/leverage checks; PaperExecutor with bps slippage; IBKRClient and normalize_bars_df; runner.py orchestration and interlocks; SQLite schema and dashboard; portfolio model; unit tests for risk and SMA.